using CSConfigGenerator.Models;
using CSConfigGenerator.Interfaces;
using System.Text;

namespace CSConfigGenerator.Services;

/// <summary>
/// ConfigStateService handles the state of configuration settings.
/// This is a unified service that replaces both PlayerConfigStateService and ServerConfigStateService.
/// It no longer distinguishes between player and server commands, treating all commands uniformly.
/// </summary>
public class ConfigStateService : IConfigStateService
{
    protected readonly ISchemaService _schemaService;
    protected readonly Dictionary<string, Setting> _settings = [];

    public event Action<object?>? OnStateChange;
    public IReadOnlyDictionary<string, Setting> Settings => _settings.AsReadOnly();

    public ConfigStateService(ISchemaService schemaService)
    {
        _schemaService = schemaService;
    }

    public virtual void InitializeDefaults()
    {
        _settings.Clear();

        foreach (var section in _schemaService.AllSections)
        {
            foreach (var command in section.Commands)
            {
                object defaultValue = command.UiData switch
                {
                    UiDataBool b => b.DefaultValue,
                    UiDataInteger i => i.DefaultValue,
                    UiDataFloat f => f.DefaultValue,
                    UiDataString s => s.DefaultValue,
                    UiDataEnum e => e.DefaultValue,
                    UiDataBitmask bm => bm.DefaultValue,
                    UiDataAction a => a.DefaultValue ?? string.Empty,
                    _ => throw new InvalidOperationException("Unknown UiData type")
                };

                _settings[command.Command] = new Setting
                {
                    Value = defaultValue,
                    IsInConfigEditor = false
                };
            }
        }

        NotifyStateChanged();
    }

    private IReadOnlyList<ConfigSection> GetSections() => _schemaService.AllSections;

    private CommandDefinition? GetCommandDefinition(string commandName) => _schemaService.GetCommand(commandName);

    protected void NotifyStateChanged(object? originator = null)
    {
        OnStateChange?.Invoke(originator);
    }

    public Setting GetSetting(string commandName)
    {
        if (_settings.TryGetValue(commandName, out var setting))
        {
            return setting;
        }

        throw new ArgumentException($"Command '{commandName}' not found.");
    }

    public string GenerateConfigFile()
    {
        var builder = new StringBuilder();
        builder.AppendLine("// Generated by CS Config Generator");
        builder.AppendLine($"// Generated on: {DateTimeOffset.Now:yyyy-MM-dd HH:mm:ss}");
        builder.AppendLine();

        foreach (var section in GetSections().OrderBy(s => s.DisplayName))
        {
            var sectionHasContent = false;

            foreach (var command in section.Commands.OrderBy(c => c.Command))
            {
                if (_settings.TryGetValue(command.Command, out var setting) && setting.IsInConfigEditor)
                {
                    if (!sectionHasContent)
                    {
                        builder.AppendLine($"// {section.DisplayName} Settings");
                        sectionHasContent = true;
                    }
                    var formattedValue = setting.Value switch
                    {
                        bool b => b ? "true" : "false",
                        float f => f.ToString(System.Globalization.CultureInfo.InvariantCulture),
                        int i => i.ToString(System.Globalization.CultureInfo.InvariantCulture),
                        string s when s.Contains(' ') || s.Contains(';') => $"\"{s}\"",
                        string s => s,
                        _ => setting.Value.ToString() ?? string.Empty
                    };
                    builder.AppendLine($"{command.Command} {formattedValue}");
                }
            }

            if (sectionHasContent) builder.AppendLine();
        }

        return builder.ToString();
    }

    public void ParseConfigFile(string configText, object? originator = null)
    {
        var lines = configText.Split(['\r', '\n'], StringSplitOptions.RemoveEmptyEntries);
        var commandsInFile = new HashSet<string>();

        foreach (var line in lines)
        {
            var trimmedLine = line.Trim();
            if (string.IsNullOrEmpty(trimmedLine) || trimmedLine.StartsWith("//"))
                continue;

            var firstSpaceIndex = trimmedLine.IndexOf(' ');
            if (firstSpaceIndex <= 0) continue;

            var commandName = trimmedLine[..firstSpaceIndex].Trim();
            var valueStr = trimmedLine[(firstSpaceIndex + 1)..].Trim().Trim('"');

            // Step 1: Check if this is a valid command
            var command = GetCommandDefinition(commandName);
            if (command == null) continue;

            commandsInFile.Add(commandName);

            // Step 2: Validate and parse the value using the polymorphic UiData model
            if (command.UiData.TryParse(valueStr, out var parsedValue))
            {
                // Step 3: Update the setting
                if (_settings.TryGetValue(commandName, out var setting))
                {
                    setting.Value = parsedValue!;
                    // If a command is present in the file, it is considered included.
                    setting.IsInConfigEditor = true;
                }
            }
        }

        // For any setting that was NOT in the config file, mark it as not included.
        foreach (var (commandName, setting) in _settings)
        {
            if (!commandsInFile.Contains(commandName))
            {
                setting.IsInConfigEditor = false;
            }
        }

        NotifyStateChanged(originator);
    }

    public void SetValue(string commandName, object value, object? originator = null)
    {
        if (_settings.TryGetValue(commandName, out var setting))
        {
            // Get the command definition to validate against
            var commandDef = GetCommandDefinition(commandName);
            if (commandDef != null)
            {
                // Convert the value to the appropriate type
                var targetType = setting.Value.GetType();
                var convertedValue = Convert.ChangeType(value, targetType, System.Globalization.CultureInfo.InvariantCulture);

                // Only update if the value has changed
                if (!setting.Value.Equals(convertedValue))
                {
                    setting.Value = convertedValue;
                    NotifyStateChanged(originator);
                }
            }
            else if (!setting.Value.Equals(value)) // Fallback if no command definition
            {
                setting.Value = value;
                NotifyStateChanged(originator);
            }
        }
    }

    public (bool, string?) TrySetValueFromString(string commandName, string valueStr, object? originator = null)
    {
        var commandDef = GetCommandDefinition(commandName);
        if (commandDef == null)
        {
            return (false, "Invalid command.");
        }

        if (commandDef.UiData.TryParse(valueStr, out var parsedValue))
        {
            SetValue(commandName, parsedValue!, originator);
            return (true, null);
        }

        // TODO: Provide more specific error messages based on the type
        return (false, "Invalid value.");
    }

    public void SetIncluded(string commandName, bool IsInConfigEditor, object? originator = null)
    {
        if (_settings.TryGetValue(commandName, out var setting))
        {
            if (setting.IsInConfigEditor != IsInConfigEditor)
            {
                setting.IsInConfigEditor = IsInConfigEditor;
                NotifyStateChanged(originator);
            }
        }
    }

    public void ResetToDefaults()
    {
        InitializeDefaults();
    }
}
