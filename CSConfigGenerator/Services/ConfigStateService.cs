using System.Globalization;
using System.Text;
using System.Text.Json;

namespace CSConfigGenerator.Services;

public class ConfigStateService(ISchemaService schemaService) : IConfigStateService
{
    private readonly ISchemaService _schemaService = schemaService;
    private readonly Dictionary<string, object> _settings = [];
    
    public event Action? OnStateChange;
    public IReadOnlyDictionary<string, object> Settings => _settings.AsReadOnly();

    public void InitializeDefaults()
    {
        _settings.Clear();
        
        foreach (var section in _schemaService.Sections)
        {
            foreach (var command in section.Commands)
            {
                var defaultValue = ConvertJsonValue(command.DefaultValue, command.Type);
                _settings[command.Name] = defaultValue;
            }
        }
        
        OnStateChange?.Invoke();
    }

    public void UpdateSetting(string commandName, object value)
    {
        var command = _schemaService.GetCommand(commandName)
            ?? throw new ArgumentException($"Command '{commandName}' not found.");
        var convertedValue = ConvertToType(value, command.Type);
        _settings[commandName] = convertedValue;
        OnStateChange?.Invoke();
    }

    public T GetSetting<T>(string commandName)
    {
        if (_settings.TryGetValue(commandName, out var value) && value is T typedValue)
        {
            return typedValue;
        }

        var command = _schemaService.GetCommand(commandName)
            ?? throw new ArgumentException($"Command '{commandName}' not found.");
        var defaultValue = ConvertJsonValue(command.DefaultValue, command.Type);
        return (T)defaultValue;
    }

    public string GenerateConfigFile()
    {
        var builder = new StringBuilder();
        builder.AppendLine("// Generated by CS Config Generator");
        builder.AppendLine($"// Generated on: {DateTime.Now:yyyy-MM-dd HH:mm:ss}");
        builder.AppendLine();

        foreach (var section in _schemaService.Sections)
        {
            builder.AppendLine($"// {section.DisplayName} Settings");
            
            foreach (var command in section.Commands)
            {
                if (_settings.TryGetValue(command.Name, out var value))
                {
                    var formattedValue = FormatValueForConfig(value);
                    builder.AppendLine($"{command.Name} \"{formattedValue}\"");
                }
            }
            
            builder.AppendLine();
        }

        return builder.ToString();
    }

    public void ParseConfigFile(string configText)
    {
        var lines = configText.Split(['\r', '\n'], StringSplitOptions.RemoveEmptyEntries);
        
        foreach (var line in lines)
        {
            var trimmedLine = line.Trim();
            if (string.IsNullOrEmpty(trimmedLine) || trimmedLine.StartsWith("//")) 
                continue;

            var firstSpaceIndex = trimmedLine.IndexOf(' ');
            if (firstSpaceIndex <= 0) continue;

            var commandName = trimmedLine[..firstSpaceIndex].Trim();
            var valueStr = trimmedLine[(firstSpaceIndex + 1)..].Trim().Trim('"');

            var command = _schemaService.GetCommand(commandName);
            if (command == null) continue;

            try
            {
                var parsedValue = ParseValueFromString(valueStr, command.Type);
                _settings[commandName] = parsedValue;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error parsing value '{valueStr}' for command '{commandName}': {ex.Message}");
            }
        }
        
        OnStateChange?.Invoke();
    }

    public void ResetToDefaults()
    {
        InitializeDefaults();
    }

    private static object ConvertJsonValue(JsonElement element, string type)
    {
        return type.ToLower() switch
        {
            "bool" => element.GetBoolean(),
            "int" => element.GetInt32(),
            "float" => element.GetSingle(),
            "string" => element.GetString() ?? string.Empty,
            "enum" => element.GetString() ?? string.Empty,
            _ => throw new ArgumentException($"Unsupported type: {type}")
        };
    }

    private static object ConvertToType(object value, string type)
    {
        return type.ToLower() switch
        {
            "bool" => Convert.ToBoolean(value),
            "int" => Convert.ToInt32(value),
            "float" => Convert.ToSingle(value),
            "string" => value.ToString() ?? string.Empty,
            "enum" => value.ToString() ?? string.Empty,
            _ => throw new ArgumentException($"Unsupported type: {type}")
        };
    }

    private static object ParseValueFromString(string valueStr, string type)
    {
        return type.ToLower() switch
        {
            "bool" => valueStr is "1" or "true",
            "int" => int.Parse(valueStr, CultureInfo.InvariantCulture),
            "float" => float.Parse(valueStr, CultureInfo.InvariantCulture),
            "string" => valueStr,
            "enum" => valueStr,
            _ => throw new ArgumentException($"Unsupported type: {type}")
        };
    }

    private static string FormatValueForConfig(object value)
    {
        return value switch
        {
            bool b => b ? "1" : "0",
            float f => f.ToString(CultureInfo.InvariantCulture),
            int i => i.ToString(CultureInfo.InvariantCulture),
            _ => value.ToString() ?? string.Empty
        };
    }
}