@using CSConfigGenerator.Models
@using CSConfigGenerator.ViewModels

@if (!ViewModel.Command.UiData.HideFromDefaultView)
{
    @if (ViewModel.Setting.IsInConfigEditor)
    {
        <div class="mb-3">
            <div class="d-flex justify-content-between">
                <label class="form-label" for="@ViewModel.Command.Command">@ViewModel.Command.UiData.Label</label>
                <button class="btn btn-sm btn-outline-danger" @onclick="ViewModel.Remove">Remove</button>
            </div>

            @switch (ViewModel.Command.UiData.Type)
            {
                case SettingType.Bool:
                    <input type="checkbox" id="@ViewModel.Command.Command" class="form-check-input" @bind="BoolValue" />
                    break;
                case SettingType.Int:
                    <input type="number" id="@ViewModel.Command.Command" class="form-control" @bind="IntValue" @bind:event="oninput" />
                    break;
                case SettingType.Float:
                    <input type="number" id="@ViewModel.Command.Command" class="form-control" @bind="FloatValue" @bind:event="oninput" />
                    break;
                case SettingType.Enum:
                    <select id="@ViewModel.Command.Command" class="form-control" @bind="StringValue">
                        @if (ViewModel.Command.UiData.Options != null)
                        {
                            @foreach (var option in ViewModel.Command.UiData.Options)
                            {
                                <option value="@option.Key">@option.Value</option>
                            }
                        }
                    </select>
                    break;
                case SettingType.String:
                case SettingType.Action: // Add action to default string handling if it uses text input
                case SettingType.UnknownNumeric: // If you decide to handle these with text input for flexibility
                case SettingType.UnknownInteger: // If you decide to handle these with text input for flexibility
                default:
                    <input type="text" id="@ViewModel.Command.Command" class="form-control" @bind="StringValue" />
                    break;
            }

            <small class="form-text text-muted">Command: <code>@ViewModel.Command.Command</code></small>
        </div>
    }
    else
    {
        <div class="mb-3">
            <div class="d-flex justify-content-between align-items-center">
                <div>
                    <span class="form-label text-muted">@ViewModel.Command.UiData.Label</span>
                    <span class="badge bg-secondary">Removed</span>
                </div>
                <button class="btn btn-sm btn-outline-success" @onclick="ViewModel.Restore">Restore</button>
            </div>
            <small class="form-text text-muted">Command: <code>@ViewModel.Command.Command</code></small>
        </div>
    }
}


@code {
    [Parameter, EditorRequired]
    public SettingViewModel ViewModel { get; set; } = null!;

    private bool BoolValue
    {
        get => ViewModel.Value is bool b ? b : false; // Safely cast with pattern matching
        set => ViewModel.Value = value;
    }
    private int IntValue
    {
        get => ViewModel.Value is int i ? i : (ViewModel.Value is float f ? (int)f : 0); // Handle int or float and provide a default
        set => ViewModel.Value = value;
    }
    private float FloatValue
    {
        get => ViewModel.Value is float f ? f : (ViewModel.Value is int i ? (float)i : 0.0f); // Handle float or int and provide a default
        set => ViewModel.Value = value;
    }
    private string StringValue
    {
        get => ViewModel.Value?.ToString() ?? string.Empty; // Safely convert to string
        set => ViewModel.Value = value;
    }
}