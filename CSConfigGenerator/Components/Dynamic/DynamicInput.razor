@using CSConfigGenerator.Models
@using CSConfigGenerator.Services

@inject ConfigStateService ConfigState

<div class="mb-3">
    <label class="form-label" for="@Command.Name">@Command.Description</label>
    
    @if (Command.Type == CommandValueType.Boolean)
    {
        <input type="checkbox" 
               id="@Command.Name" 
               class="form-check-input" 
               @bind="BoolValue" />
    }
    else if (Command.Type == CommandValueType.Numeric)
    {
        <input type="number" 
               id="@Command.Name" 
               class="form-control" 
               @bind="FloatValue"
               step="@(Command.Step?.ToString() ?? "0.01")"
               min="@Command.MinValue"
               max="@Command.MaxValue" />
    }
    else if (Command.Type == CommandValueType.Enum && Command.Options != null)
    {
        <select id="@Command.Name" 
                class="form-control" 
                @bind="StringValue">
            @foreach (var option in Command.Options)
            {
                <option value="@option.Key">@option.Value</option>
            }
        </select>
    }
    else
    {
        <input type="text" 
               id="@Command.Name" 
               class="form-control" 
               @bind="StringValue" />
    }
    
    <small class="form-text text-muted">Command: @Command.Name</small>
</div>

@code {
    [Parameter, EditorRequired]
    public CommandDefinition Command { get; set; } = null!;

    private bool BoolValue
    {
        get => GetValue<bool>();
        set => SetValue(value);
    }

    private float FloatValue
    {
        get => GetValue<float>();
        set => SetValue(value);
    }

    private string StringValue
    {
        get => GetValue<string>();
        set => SetValue(value ?? string.Empty);
    }

    private T GetValue<T>()
    {
        if (ConfigState.Settings.TryGetValue(Command.Name, out var value))
        {
            // Handle direct type match
            if (value is T directValue)
                return directValue;
                
            // Handle conversions
            if (typeof(T) == typeof(bool))
            {
                return (T)(object)ConvertToBoolean(value);
            }
            
            if (typeof(T) == typeof(float))
            {
                return (T)(object)ConvertToFloat(value);
            }
            
            if (typeof(T) == typeof(string))
            {
                return (T)(object)(value?.ToString() ?? string.Empty);
            }
        }
        
        return GetDefaultValue<T>();
    }

    private void SetValue(object value)
    {
        ConfigState.UpdateSetting(Command.Name, value);
    }

    private static bool ConvertToBoolean(object? value)
    {
        return value switch
        {
            bool b => b,
            string s => s == "1" || s.Equals("true", StringComparison.OrdinalIgnoreCase),
            int i => i != 0,
            float f => f != 0,
            _ => false
        };
    }

    private static float ConvertToFloat(object? value)
    {
        return value switch
        {
            float f => f,
            int i => i,
            string s when float.TryParse(s, out var parsed) => parsed,
            _ => 0f
        };
    }

    private T GetDefaultValue<T>()
    {
        if (Command.DefaultValue != null)
        {
            try
            {
                if (Command.DefaultValue is T defaultValue)
                    return defaultValue;
                    
                if (typeof(T) == typeof(bool))
                    return (T)(object)ConvertToBoolean(Command.DefaultValue);
                if (typeof(T) == typeof(float))
                    return (T)(object)ConvertToFloat(Command.DefaultValue);
                if (typeof(T) == typeof(string))
                    return (T)(object)(Command.DefaultValue.ToString() ?? string.Empty);
            }
            catch
            {
            }
        }

        if (typeof(T) == typeof(bool))
            return (T)(object)false;
        if (typeof(T) == typeof(float))
            return (T)(object)0f;
        if (typeof(T) == typeof(string))
            return (T)(object)string.Empty;
            
        return default(T)!;
    }
}