@using CSConfigGenerator.Models
@using CSConfigGenerator.ViewModels
@using System.Globalization

<div class="mb-3">
    <div class="d-flex justify-content-between align-items-center">
        <div>
            <label class="form-label @(ViewModel.Setting.IsInConfigEditor ? "" : "text-muted")" for="@ViewModel.Command.Command">
                    @ViewModel.Command.UiData.Label
                </label>
                @if (!ViewModel.Setting.IsInConfigEditor)
                {
                    <span class="badge bg-secondary ms-2">Removed</span>
                }
            </div>
            @if (ViewModel.Setting.IsInConfigEditor)
            {
                <button class="btn btn-sm btn-outline-danger" @onclick="ViewModel.Remove">Remove</button>
            }
            else
            {
                <button class="btn btn-sm btn-outline-success" @onclick="ViewModel.Restore">Restore</button>
            }
        </div>

        @if (ViewModel.Setting.IsInConfigEditor)
        {
            @switch (ViewModel.Command.UiData.Type)
            {
                case SettingType.Bool:
                    <input type="checkbox" id="@ViewModel.Command.Command" class="form-check-input" @bind="BoolValue" />
                    break;
                case SettingType.Int:
                case SettingType.Float:
                case SettingType.UnknownInteger:
                case SettingType.UnknownNumeric:
                    <input type="text"
                           id="@ViewModel.Command.Command"
                           class="form-control @(string.IsNullOrEmpty(ValidationMessage) ? "" : "is-invalid")"
                           @oninput="OnInputChanged"
                           value="@CurrentValue"
                           spellcheck="false" />
                    @if (!string.IsNullOrEmpty(ValidationMessage))
                    {
                        <div class="invalid-feedback d-block">@ValidationMessage</div>
                    }
                    break;
                case SettingType.Enum:
                    <select id="@ViewModel.Command.Command" class="form-control" @bind="StringValue">
                        @if (ViewModel.Command.UiData.Options != null)
                        {
                            @foreach (var option in ViewModel.Command.UiData.Options)
                            {
                                <option value="@option.Key">@option.Value</option>
                            }
                        }
                    </select>
                    break;
                case SettingType.String:
                case SettingType.Action:
                default:
                    <input type="text" id="@ViewModel.Command.Command" class="form-control" @bind="StringValue" @bind:event="oninput" spellcheck="false" />
                    break;
            }
        }

        <small class="form-text text-muted">Command: <code>@ViewModel.Command.Command</code></small>
    </div>

@code {
    [Parameter, EditorRequired]
    public SettingViewModel ViewModel { get; set; } = null!;

    private string CurrentValue { get; set; } = string.Empty;
    private string? ValidationMessage { get; set; }

    protected override void OnParametersSet()
    {
        // This is the fix for the editor -> UI sync bug.
        // It ensures that the local CurrentValue is updated whenever the parent component re-renders.
        CurrentValue = string.Format(CultureInfo.InvariantCulture, "{0}", ViewModel.Value);
    }

    // Two-way binding for boolean values (checkboxes)
    private bool BoolValue
    {
        get => ViewModel.Value is bool b && b;
        set => HandleChange(value.ToString().ToLowerInvariant());
    }

    // Two-way binding for string-based values (selects, text inputs)
    private string StringValue
    {
        get => ViewModel.Value?.ToString() ?? string.Empty;
        set => HandleChange(value);
    }

    // Handler for numeric inputs, which don't use @bind
    private void OnInputChanged(ChangeEventArgs e)
    {
        var value = e.Value?.ToString() ?? string.Empty;
        CurrentValue = value; // Update the local value to show what the user is typing
        HandleChange(value);
    }

    private void HandleChange(string value)
    {
        var (isValid, errorMessage) = ViewModel.TrySetValueFromString(value);
        if (isValid)
        {
            ValidationMessage = null;
        }
        else
        {
            ValidationMessage = errorMessage;
        }
    }
}