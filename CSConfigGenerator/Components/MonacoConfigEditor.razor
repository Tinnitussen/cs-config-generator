@using BlazorMonaco.Editor
@using CSConfigGenerator.Interfaces
@inject IJSRuntime JSRuntime
@inject IEditorIntellisenseService IntellisenseService

<div class="monaco-editor-wrapper">
    <StandaloneCodeEditor @ref="_editor" Id="config-editor" ConstructionOptions="EditorConstructionOptions" OnDidInit="EditorOnDidInit" />
</div>

<style>
    .monaco-editor-wrapper {
        height: 100%;
        width: 100%;
        display: flex;
        flex-direction: column;
        min-height: 400px;
        border: 1px solid var(--color-border);
        border-radius: var(--border-radius);
        min-width: 0;
        overflow: hidden;
        background-color: var(--color-bg-base);
    }

    /* BlazorMonaco renders a host div with this id; ensure it can actually grow inside flex layouts. */
    #config-editor {
        flex: 1 1 auto;
        width: 100%;
        height: 100%;
        min-width: 0;
        min-height: 0;
    }
</style>

@code {
    // NOTE: @ref is assigned before the underlying JS editor exists. We must not call any
    // BlazorMonaco JS interop until OnDidInit fires.
    private StandaloneCodeEditor? _editor;
    private bool _isEditorInitialized;
    private TextModel? _pendingModel;
    private string? _currentModelUri;
    private bool _disposed;
    private bool _didInitialLayout;

    [Parameter]
    public TextModel? Model { get; set; }

    [Parameter]
    public EventCallback OnEditorInit { get; set; }

    private StandaloneEditorConstructionOptions EditorConstructionOptions(StandaloneCodeEditor editor)
    {
        return new StandaloneEditorConstructionOptions
        {
            AutomaticLayout = true,
            Language = "cs2config",
            Theme = "vs-dark",
            Minimap = new EditorMinimapOptions { Enabled = false },
            AutoIndent = "none"
        };
    }

    protected override async Task OnInitializedAsync()
    {
        // Initialize intellisense before the editor renders to ensure the language is registered
        await IntellisenseService.InitializeAsync();
    }

    private async Task EditorOnDidInit()
    {
        _isEditorInitialized = true;

        // Prefer the latest incoming parameter value; fallback to any pending value captured
        // before the editor was initialized.
        var modelToApply = Model ?? _pendingModel;
        _pendingModel = null;

        if (modelToApply != null)
        {
            await ApplyModelIfNeeded(modelToApply);
        }

        // Monaco sometimes initializes while its container is at 0 width/height in Blazor.
        // Force a layout once the editor is fully initialized.
        _didInitialLayout = false;

        if (!_disposed)
        {
            await OnEditorInit.InvokeAsync();
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (_disposed)
            return;

        if (_isEditorInitialized && !_didInitialLayout)
        {
            _didInitialLayout = true;
            // Let the browser apply layout first, then force Monaco to re-measure.
            await Task.Yield();
            await Layout();
        }
    }

    protected override async Task OnParametersSetAsync()
    {
        if (_disposed)
            return;

        if (Model == null)
            return;

        // If the editor JS instance isn't created yet, defer model application until OnDidInit.
        if (!_isEditorInitialized)
        {
            _pendingModel = Model;
            return;
        }

        await ApplyModelIfNeeded(Model);
    }

    public async Task Layout()
    {
        if (_disposed)
            return;

        if (_editor != null && _isEditorInitialized)
        {
            await _editor.Layout();
        }
    }

    private async Task ApplyModelIfNeeded(TextModel model)
    {
        if (_disposed || _editor == null || !_isEditorInitialized)
            return;

        // Avoid calling GetModel() here: it's a JS interop call and can race during init.
        var modelUri = model.Uri;
        if (_currentModelUri == modelUri)
            return;

        _currentModelUri = modelUri;
        await _editor.SetModel(model);
        // Immediately re-layout after model swaps; this fixes the "2px wide editor" glitch in practice.
        await _editor.Layout();

        // Set up validation for syntax errors and unknown commands
        await JSRuntime.InvokeVoidAsync("setupCs2ConfigValidation", "config-editor");
    }

    public void Dispose()
    {
        _disposed = true;
    }
}
